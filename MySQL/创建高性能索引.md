高性能索引的学习记录。——Chau



<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [**索引的优点**](#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9)
- [**索引策略**](#%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5)
  - [**独立的列**](#%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%88%97)
  - [**前缀索引和索引选择性**](#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E6%80%A7)
    - [前缀索引示例](#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E7%A4%BA%E4%BE%8B)
    - [前缀索引缺点](#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E7%BC%BA%E7%82%B9)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->





## **索引的优点**

索引可以让服务器快速地定位到表的指定位置。但是这也并不是索引的唯一作用，到目前为止可以看到，根据创建索引的数据结构不同，索引也有一些其他的附加作用。

1. 索引大大减少了服务器需要扫描的数据量
2. 索引可以帮助服务器避免排序和临时表
3. 索引可以将随机I/O变为顺序I/O



## **索引策略**

### **独立的列**

指索引列不能是表达式的一部分，也不能是函数的参数。

例如：

```mysql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

虽然能看出WHERE中的表达式等价于`actor_id = 4`，但是MySQL无法自动解析这个方程式。我们要养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。

```mysql
SELECT actor_id FROM sakila.actor WHERE actor_id = 4;
```



### **前缀索引和索引选择性**

有时候需要索引很长的字符列，这会让索引变得大且慢。

通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指，**不重复的索引值（也称为基数，cardinality）和数据表的记录总数（#T）的比值**，范围从1/#T到1之间。**索引的选择性越高则查询效率越高**，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

对于**BLOB**、**TEXT**或者很长的**VARCHAR**类型的列，**必须**使用前缀索引，因为MySQL不允许索引这些列的完整长度。

诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引的整个列。换句话说，就是前缀的“基数”应该接近于完整列的“基数”。

为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较。



#### 前缀索引示例

通过示例数据库`sakila`创建示例表`city_demo`

```mysql
CREATE TABLE sakila.city_demo(city VARCHAR(50) NOT NULL);
```

插入数据

```mysql
INSERT INTO sakila.city_demo(city) SELECT city FROM sakila.city;
```

重复下面的语句5次

```mysql
INSERT INTO sakila.city_demo(city) SELECT city FROM sakila.city_demo;
```

使用`RAND()`随机分配

```mysql
UPDATE sakila.city_demo
set city = (SELECT city FROM sakila.city ORDER BY RAND() LIMIT 1);
```

![image-20211021150449056](创建高性能索引.assets/image-20211021150449056.png)



现在有了示例数据集，我们找到最常见的城市列表：

```mysql
SELECT COUNT(*) AS cnt,city
FROM sakila.city_demo GROUP BY city ORDER BY cnt DESC LIMIT 10;
```

![image-20211021151535849](创建高性能索引.assets/image-20211021151535849.png)



现在查找最频繁出现的城市的前缀，先从3个前缀字母开始。

```mysql
SELECT COUNT(*) AS cnt, LEFT(city, 3) AS pref
FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;
```

![image-20211021152151040](创建高性能索引.assets/image-20211021152151040.png)



每个前缀都比原来的城市出现的次数更多，因此唯一前缀比唯一城市要少很多。然后我们增加前缀长度，直到这个前缀的选择性接近完整列的选择性。通过不断添加前缀长度，可以发现前缀长度到达7的时候比较合适。

```mysql
SELECT COUNT(*) AS cnt, LEFT(city, 7) AS pref
FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;
```

![image-20211021152934918](创建高性能索引.assets/image-20211021152934918.png)



计算合适的前缀长度的另外一个办法就是通过计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。

下面显示如何计算完整列的选择性：

```mysql
SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;
```

![image-20211021153555685](创建高性能索引.assets/image-20211021153555685.png)

接下来，针对不同前缀长度进行计算。

```mysql
SELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3,
COUNT(DISTINCT LEFT(city, 4))/COUNT(*) AS sel4,
COUNT(DISTINCT LEFT(city, 5))/COUNT(*) AS sel5,
COUNT(DISTINCT LEFT(city, 6))/COUNT(*) AS sel6,
COUNT(DISTINCT LEFT(city, 7))/COUNT(*) AS sel7,
COUNT(DISTINCT LEFT(city, 8))/COUNT(*) AS sel8
FROM sakila.city_demo;
```

![image-20211021154021591](创建高性能索引.assets/image-20211021154021591.png)

可以看到，当前缀长度到达7的时候，再增加前缀长度，选择性提升的幅度已经很小，而且也接近完整列的选择性。

在上面的示例中，已经找到合适的前缀长度，下面演示一下如何创建前缀索引：

```mysql
ALTER TABLE sakila.city_demo ADD KEY(city(7));
```





#### 前缀索引缺点

前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有缺点：MySQL无法使用前缀索引做`ORDER BY`和`GROUP BY`，也无法使用前缀索引做覆盖扫描。



### 多列索引

在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0和更新版本引入一种叫“索引合并”（index merge）的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。